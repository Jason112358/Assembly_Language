# 8086 寻址方式
+ 16位CPU无法接受更长的数据
+ 物理地址 = 段地址 * 16 + 偏移地址
+ CFF0 ： 0FA7 可自动生成段地址加偏移的格式
+ 基地址很有用

# 内存的分段管理
+ 基地址（段地址*16） + 偏移量 = 物理地址
+ 格式 0xFFCA:0x0005    (CS:IP)
+ 段地址一定为16的整数倍
## 段寄存器
+ 段寄存器专门用于存储段地址，即格式中的0xFFCA部分
+ 语法 mov 段寄存器,FFCAH
+ 8086有四个段寄存器
    + CS (Code Segment) ：代码段寄存器
    + DS (Data Segment) ：数据段寄存器
    + SS (Stack Segment) ：堆栈段寄存器
    + ES (Extra Segment) ：附加段寄存器  
    * 通过不同的段寄存器，CPU知道读入的本段为数据/指令，得到段寄存器中的段地址后再由IP指令指针寄存器获得偏移地址得到指令的地址
* **不同的段寄存器内CPU会看作不同的事物对待，即段寄存器用于将所有数据分类处理**

+ 高高低低 高地址付给高地址  
+ 指令由数据总线传至指令缓冲器，以计算下一步IP取指令的位置，IP+本次执行的指令的位数  

## jmp指令
+ mov指令不能直接给CS;IP赋值，但CS;IP不为RO(readOnly)，通过jmp指令来改变CS;IP
+ e.g. jmp 2AE3:3，执行后`CS=2AE3H`，`IP=0003H`，CPU从`2AE33H`处读取指令
+ 在计算位置时需要计算清指令地址
+ 8086允许jmp至合法寄存器，不允许jmp直接加位置，若要jmp至某一特定位置，可以：
> mov ax,3H  
jmp ax

## __数据段DS寄存器__ 2019-11-2
+ 数据段需要偏移，代码段需要IP
+ DS(Data Segment)数据段寄存器，用于存放要访问数据的段地址
+ 有可能指令寄存器与数据段寄存器都指向一段代码
+ AL，AH指一个寄存器中的低八位与低八位
### 示例1
```
mov bx,1000H
mov ds,bx
mov al,[0]
```
+ 中括号中为字节为单位的偏移地址，第三行意义与 `mov al,[ds:0]` 相同，但格式不为此
+ __8086不能直接给段寄存器赋值__
***
### 示例2
```
mov bx,1000H
mov ds,bx
mov [0],al
```
+ 这里将al的值赋给偏移地址
+ 8086小端 高高低低
+ 寄存器多大，之后的数据就读多长，以下语句不合法 `mov [0],[1]`，因为没有长度标准，不知道读多少字节数据
## 大端小端
+ 大端模式 （Big Endian)
    + 数据高字节保存在内存低地址中，数据低字节保存在内存高地址中。
    + 高低\低高
+ 小端模式 （Small Endian）
    + 数据高字节保存在内存高地址中，数据低字节保存在内存低地址中。
    + 高高\低低
+ ARM 既有大端模式又有小端模式

__数据与代码无区别，只有放入不同的段寄存器才会赋予其不同的意义。__

## 练习
利用栈可以实现值的交换

# 栈段
+ 对8086可在编程时根据需要将一组内存单元定义为一个段
+ 在对偏移赋值时也要满足格式与位数匹配，即16位与2字节，4个十六进制数匹配，即0020H
+ SS放段地址，SP放偏移地址（栈顶单元偏移地址放入SP作为栈段配置的初始化）
+ 练习
    >mov ax, 2000H  
     mov ss, ax  
     mov sp, 0010H  
     实现20000H到20010H的栈段初始化
+ 内存中读写都向高地址操作，栈的PUSH向低地址

# Loop指令
